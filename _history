{"entries":[{"timestamp":1722995162079,"editorVersion":"1.7.28","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":225,"start2":225,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"minecraftOnChat\">\n    <value name=\"command\">\n      <shadow type=\"text\">\n        <field name=\"TEXT\">run</field>\n      </shadow>\n    </value>\n  </block>\n</xml>"}]}],"snapshots":[{"timestamp":1722995162073,"editorVersion":"1.7.28","text":{"main.ts":"","README.md":"","main.py":"# MINECRAFT MAZES v1.0\n# Copyright 2021, David Bailey / Crux\n# Looking for instructions or more info? Try here:                    \n# https://github.com/crux888/minecraft-mazes-makecode  \n\n\n# Do you want your mazes to look different?\n# If so, then try changing these values...\nmaze_blocks = DIAMOND_BLOCK\ntower_blocks = STONE_BRICKS\npyramid_blocks = CHISELED_SANDSTONE\ndiamond_blocks = GOLD_BLOCK\nadd_torches = True\nsolve_maze = True\nwall_height = 2\n\n\n# Hmmm, I wouldn't recommend changing any of these values though...\n# They're global constants and variables used throughout the code\nmaze_type = \"\"\nmaze_rows = 0\nmaze_columns = 0\nmaze_layers = 0\nplayer_position: Position = None\nmaze_position: Position = None\nentrance_position: Position = None\nexit_position: Position = None\nrobot_position: Position = None\nrobot_orientation = \"\"\nmaze_solve_path: List[str] = []\nblocks_used = 0\ntorches_used = 0\nwall_blocks = 0\ntime_start = 0\ncurrent_layer = 0\nmiddle_layer = 0\nx_offset = 0\nz_offset = 0\nsearched_steps = 0\nsolution_steps = 0\npath_block = LIME_CARPET\nmaximum_maze_rows_columns = 25\nmaximum_maze_layers = 10\nminimum_maze_rows_columns = 3\nminimum_maze_layers = 3\n\n\n###############\n# SIMPLE MAZE #\n###############\n\ndef on_on_chat(rows, columns):\n    # Define global variables\n    global maze_type, maze_rows, maze_columns, maze_layers\n    # Set global variables for this type of maze\n    maze_type = \"maze\"\n    maze_rows = rows\n    maze_columns = columns\n    maze_layers = 1\n    # Run the main loop to build and solve the maze\n    mainLoop()\nplayer.on_chat(\"maze\", on_on_chat)\n\n\n##############\n# TOWER MAZE #\n##############\n\ndef on_on_chat2(rows, columns, layers):\n    # Define global variables\n    global maze_type, maze_rows, maze_columns, maze_layers\n    # Set global variables for this type of maze\n    maze_type = \"tower\"\n    maze_rows = rows\n    maze_columns = columns\n    maze_layers = layers\n    # Run the main loop to build and solve the maze\n    mainLoop()\nplayer.on_chat(\"tower\", on_on_chat2)\n\n\n################\n# PYRAMID MAZE #\n################\n\ndef on_on_chat3(layers):\n    # Define global variables\n    global maze_type, maze_layers\n    # Set global variables for this type of maze\n    maze_type = \"pyramid\"\n    maze_layers = layers\n    # Run the main loop to build and solve the maze\n    mainLoop()\nplayer.on_chat(\"pyramid\", on_on_chat3)\n\n\n################\n# DIAMOND MAZE #\n################\n\ndef on_on_chat4(layers):\n    # Define global variables\n    global maze_type, maze_layers\n    # Set global variables for this type of maze\n    maze_type = \"diamond\"\n    maze_layers = layers\n    # Run the main loop to build and solve the maze\n    mainLoop()\nplayer.on_chat(\"diamond\", on_on_chat4)\n\n\n#############\n# MAIN LOOP #\n#############\n\ndef mainLoop():\n    # Define global variables\n    global maze_type, maze_rows, maze_columns, maze_layers, current_layer, middle_layer\n    # Initialise maze variables\n    initialiseMazeVariables()\n    # Draw a foundation layer underneath the maze\n    drawMazeFoundations()\n    # Build the maze layers\n    current_layer = maze_layers\n    for index in range (maze_layers):\n        if maze_type == \"pyramid\":\n            # Set maze_rows and maze_columns for a pyramid maze\n            maze_rows = current_layer * 2 + 1\n            maze_columns = maze_rows\n        elif maze_type == \"diamond\":\n            # Set maze_rows and maze_columns for a diamond maze\n            if current_layer >= middle_layer:\n                maze_rows = (maze_layers - current_layer + 1) * 2 + 1\n            else:\n                maze_rows = (maze_layers - middle_layer + 1) * 2 + 1 - ((middle_layer - current_layer) * 2)\n            maze_columns = maze_rows\n        # Draw the maze grid\n        drawMazeGrid()\n        # Build the maze, dude\n        buildMaze()\n        # Add a roof for tower, pyramid, or diamond mazes\n        if (maze_type in [\"tower\", \"pyramid\", \"diamond\"]):\n            drawMazeRoof()\n        current_layer -= 1\n    # Draw the maze doors\n    drawMazeDoors()\n    # Show the maze information\n    showMazeInfo()\n    # Solve the maze, babe\n    if solve_maze:\n        solveMaze()\n\n\ndef initialiseMazeVariables():\n    # Define global variables\n    global maze_type, maze_rows, maze_columns, player_position, maze_position, maze_blocks\n    global blocks_used, torches_used, wall_blocks, time_start, middle_layer\n    global tower_blocks, pyramid_blocks, diamond_blocks\n    # Check if the maze needs resizing\n    checkMazeSize()\n    # Set additional variables for diamond mazes\n    if maze_type == \"diamond\":\n        maze_rows = 3\n        maze_columns = 3\n        middle_layer = Math.ceil(maze_layers / 2)\n    # Display a status message\n    if (maze_type == \"maze\"):\n        player.say(\"Creating maze...\")\n    else:\n        player.say(\"Creating \" + maze_type + \" maze...\")\n    # Save the original position of the player in case they move while the maze is being built\n    player_position = player.position()\n    # Set the corner position of the maze so that the player will be facing the entrance/exit\n    if (maze_type == \"pyramid\"):\n        maze_position = positions.add(player_position,\n            pos(maze_layers * -2, 0, 3))\n    else:\n        maze_position = positions.add(player_position,\n            pos((Math.ceil(maze_columns / 2) -1) * -2, 0, 3))\n    # Check if the maze_blocks variable needs updating for tower, pyramid, or diamond mazes\n    if (maze_type == \"tower\"):\n        wall_blocks = tower_blocks\n    elif (maze_type == \"pyramid\"):\n        wall_blocks = pyramid_blocks\n    elif (maze_type == \"diamond\"):\n        wall_blocks = diamond_blocks\n    else:\n        wall_blocks = maze_blocks\n    # Reset maze counters and timer\n    blocks_used = 0\n    torches_used = 0\n    time_start = gameplay.time_query(GAME_TIME)\n\n\ndef checkMazeSize():\n    # Define global variables\n    global maze_type, maze_rows, maze_columns, maze_layers, wall_height, add_torches\n    # Set the message flag to false\n    show_resize_message = False\n    # Check maze_rows and maze_columns\n    if (maze_type in [\"maze\", \"tower\"]):\n        if (maze_rows < minimum_maze_rows_columns):\n            maze_rows = minimum_maze_rows_columns\n            show_resize_message = True\n        elif (maze_rows > maximum_maze_rows_columns):\n            maze_rows = maximum_maze_rows_columns\n            show_resize_message = True\n        if (maze_columns < minimum_maze_rows_columns):\n            maze_columns = minimum_maze_rows_columns\n            show_resize_message = True\n        elif (maze_columns > maximum_maze_rows_columns):\n            maze_columns = maximum_maze_rows_columns\n            show_resize_message = True\n    # Check maze_layers\n    if (maze_type in [\"tower\", \"pyramid\", \"diamond\"]):\n        if (maze_layers < minimum_maze_layers):\n            maze_layers = minimum_maze_layers\n            show_resize_message = True\n        elif (maze_layers > maximum_maze_layers):\n            maze_layers = maximum_maze_layers\n            show_resize_message = True\n    # Make sure that maze_layers is an odd number for diamond mazes\n    if maze_type == \"diamond\":\n        if Math.round(maze_layers / 2) == maze_layers / 2:\n            maze_layers += 1\n            show_resize_message = True\n    # Check wall_height\n    if wall_height < 2:\n        if maze_type == \"maze\":\n            wall_height = 1\n            add_torches = False\n        else:\n            wall_height = 2\n    # Display a status message if the maze has been resized\n    if (show_resize_message):\n        if (maze_type == \"maze\"):\n            player.say(\"Resized maze (\" + str(maze_rows) + \" x \" + str(maze_columns) + \")\")\n        elif (maze_type == \"tower\"):\n            player.say(\"Resized tower maze (\" + str(maze_rows) + \" x \" + str(maze_columns) + \" x \" + str(maze_layers) + \")\")\n        elif (maze_type in [\"pyramid\", \"diamond\"]):\n            player.say(\"Resized \" + maze_type + \" maze (\" + str(maze_layers) + \" layers)\")\n\n\ndef drawMazeFoundations():\n    # Define global variables\n    global maze_rows, maze_columns, maze_layers, maze_position, maze_blocks, blocks_used\n    # Check if maze_rows and maze_columns need calculating for a pyramid or diamond maze_columns\n    if (maze_type == \"pyramid\"):\n        maze_rows = maze_layers * 2 + 1\n        maze_columns = maze_layers * 2 + 1\n    elif (maze_type == \"diamond\"):\n        maze_rows = 3\n        maze_columns = 3\n    # Draw a foundation layer underneath the maze\n    blocks.fill(wall_blocks,\n        positions.add(maze_position, pos(-1, -1, -1)),\n        positions.add(maze_position, \n        pos(maze_columns * 2 - 1, -1, maze_rows *2 -1)),\n        FillOperation.REPLACE)\n    # Update the blocks_used variable based on the size of the foundation layer\n    blocks_used += (maze_rows * 2 + 1) * (maze_columns * 2 + 1)\n\n\ndef drawMazeGrid():\n    # Define global variables\n    global maze_rows, maze_columns, maze_layers, maze_position, maze_blocks, blocks_used, wall_height\n    # Initialise local variables/constants\n    x_coordinate = maze_position.get_value(Axis.X) - 1\n    y_coordinate = maze_position.get_value(Axis.Y)\n    z_coordinate = maze_position.get_value(Axis.Z) - 1\n    # Clear space for the maze by filling the area with air\n    blocks.fill(AIR,\n        world(x_coordinate, y_coordinate, z_coordinate),\n        world(x_coordinate + maze_columns * 2,\n            y_coordinate + wall_height - 1,\n            z_coordinate + maze_rows * 2),\n        FillOperation.REPLACE)\n    # Draw the maze rows\n    line_length = maze_columns * 2\n    for index in range(maze_rows + 1):\n        blocks.fill(wall_blocks,\n            world(x_coordinate, y_coordinate, z_coordinate),\n            world(x_coordinate + line_length,\n                y_coordinate + wall_height - 1,\n                z_coordinate),\n            FillOperation.REPLACE)\n        z_coordinate += 2\n    # Draw the maze columns\n    line_length = maze_rows * 2\n    z_coordinate = maze_position.get_value(Axis.Z) - 1\n    for index in range(maze_columns + 1):\n        blocks.fill(wall_blocks,\n            world(x_coordinate, y_coordinate, z_coordinate),\n            world(x_coordinate,\n                y_coordinate + wall_height - 1,\n                z_coordinate + line_length),\n            FillOperation.REPLACE)\n        x_coordinate += 2\n    # Update the blocks_used variable based on the size of maze grid\n    blocks_used += ((maze_rows + 1) * (maze_columns * 2 + 1) \n        + maze_columns * (maze_rows + 1)) * wall_height\n\n\ndef buildMaze():\n    # Define global variables\n    global maze_rows, maze_columns, maze_layers, maze_position, maze_blocks, blocks_used, torches_used, wall_height\n    # Intialise local variables\n    unvisited_neighbours: List[str] = []\n    current_cell_row = 0\n    current_cell_column = 0\n    current_cell_position_in_list = 0\n    connection_direction = \"\"\n    x_coordinate = 0\n    y_coordinate = 0\n    z_coordinate = 0\n    # Create a list of unvisited cells\n    cell_unvisited: List[number] = []\n    for index in range(maze_rows * maze_columns):\n        cell_unvisited.append(1)\n    # Create the empty stack\n    stack_rows: List[number] = []\n    stack_columns: List[number] = []\n    # Add a random cell to the top of the stack\n    stack_rows.append(randint(1, maze_rows) - 1)\n    stack_columns.append(randint(1, maze_columns) - 1)\n    # Main loop that keeps running until there are no cells left in the stack\n    while len(stack_rows) > 0:\n        # Get the current cell from the top of the stack\n        current_cell_row = stack_rows[len(stack_rows) - 1]\n        current_cell_column = stack_columns[len(stack_columns) - 1]\n        # Calculate the x, y, and z coordinates of the current cell\n        x_coordinate = maze_position.get_value(Axis.X) + (maze_columns - current_cell_column - 1) * 2\n        y_coordinate = maze_position.get_value(Axis.Y) + 0\n        z_coordinate = maze_position.get_value(Axis.Z) + (maze_rows - current_cell_row - 1) * 2\n        # Mark the current cell as \"visited\"\n        cell_unvisited[current_cell_row * maze_columns + current_cell_column] = 0\n        # Get a list of unvisited neighbours for the current cell\n        unvisited_neighbours = []\n        current_cell_position_in_list = current_cell_row * maze_columns + current_cell_column\n        if current_cell_row != 0:\n            if (cell_unvisited[current_cell_position_in_list - maze_columns] == 1):\n                unvisited_neighbours.append(\"N\")\n        if current_cell_row != maze_rows - 1:\n            if (cell_unvisited[current_cell_position_in_list + maze_columns] == 1):\n                unvisited_neighbours.append(\"S\")\n        if current_cell_column != maze_columns - 1:\n            if (cell_unvisited[current_cell_position_in_list + 1] == 1):\n                unvisited_neighbours.append(\"E\")\n        if current_cell_column != 0:\n            if (cell_unvisited[current_cell_position_in_list - 1] == 1):\n                unvisited_neighbours.append(\"W\")\n        # Check if there are unvisited neighbours\n        if len(unvisited_neighbours) == 0:\n            # There are no unvisited neighbours, so remove the current cell from the top of the stack\n            stack_rows.pop()\n            stack_columns.pop()\n        else:\n            # There are unvisited neighbours, so choose one at random, and add it to the top of the stack\n            x_offset = 0\n            z_offset = 0\n            connection_direction = unvisited_neighbours._pick_random()\n            if connection_direction == \"N\":\n                z_offset = 1\n                stack_rows.append(current_cell_row - 1)\n                stack_columns.append(current_cell_column)\n            elif connection_direction == \"S\":\n                z_offset = -1\n                stack_rows.append(current_cell_row + 1)\n                stack_columns.append(current_cell_column)\n            elif connection_direction == \"E\":\n                x_offset = -1\n                stack_rows.append(current_cell_row)\n                stack_columns.append(current_cell_column + 1)\n            elif connection_direction == \"W\":\n                x_offset = 1\n                stack_rows.append(current_cell_row)\n                stack_columns.append(current_cell_column - 1)\n            else:\n                player.say(\"Error: Unknown connection_direction\")\n            # Carve a path between the current cell and the new, unvisited neighbour\n            blocks.fill(AIR,\n                world(x_coordinate + x_offset,\n                    y_coordinate + 0,\n                    z_coordinate + z_offset),\n                    world(x_coordinate + x_offset,\n                    y_coordinate + wall_height - 1,\n                    z_coordinate + z_offset),\n                FillOperation.REPLACE)\n            # Update the blocks_used variable to account for the blocks that have been removed\n            blocks_used = blocks_used - wall_height\n            # Add torches to the maze\n            if (add_torches):\n                if randint(1, 3) == 1:\n                    blocks.place(TORCH, world(x_coordinate + 0, y_coordinate + 1, z_coordinate + 0))\n                    torches_used += 1\n            \n\ndef drawMazeRoof():\n    # Define global variables\n    global maze_type, maze_rows, maze_columns, maze_layers, maze_position, wall_height\n    global wall_blocks, blocks_used, current_layer, entrance_position, middle_layer\n    # Initialise local variables\n    x_offset = 0\n    z_offset = 0\n    roof_position1: Position = None\n    roof_position2: Position = None\n    # Draw a roof on the maze layer\n    if maze_type == \"tower\":\n        # Set the roof coordinates for a tower maze\n        roof_position1 = positions.add(maze_position, \n        pos(-1, wall_height, -1))\n        roof_position2 = positions.add(maze_position, \n        pos(maze_columns * 2 - 1, wall_height * 2 - 1, maze_rows * 2 - 1))\n        # Set the entrance position for a tower maze\n        if current_layer == 1:\n            x_offset = (Math.ceil(maze_columns / 2) - 1) * 2\n            z_offset = (Math.ceil(maze_rows / 2) - 1) * 2\n        else:\n            x_offset = randint(0, maze_columns - 1) * 2\n            z_offset = randint(0, maze_rows - 1) * 2\n        entrance_position = positions.add(maze_position, pos(x_offset, 0, z_offset))\n        # Move the tower maze up to the next layer\n        maze_position = positions.add(maze_position, pos(0, wall_height * 2, 0))\n\n    elif maze_type == \"pyramid\":\n        # Set the roof coordinates for a pyramid maze (roof is smaller than current layer)\n        roof_position1 = positions.add(maze_position, \n        pos(0, wall_height, 0))\n        roof_position2 = positions.add(maze_position,\n        pos(maze_columns * 2 - 2, wall_height * 2 - 1, maze_rows * 2 - 2))\n        # Set the entrance offsets for a pyramid maze (roof is smaller than current layer)\n        x_offset = randint(1, maze_columns - 2) * 2\n        z_offset = randint(1, maze_rows - 2) * 2\n        entrance_position = positions.add(maze_position, pos(x_offset, 0, z_offset))\n        # Move the pyramid maze up to the next layer (decreasing in size)\n        maze_position = positions.add(maze_position, pos(2, wall_height * 2, 2))\n\n    elif maze_type == \"diamond\":\n        if current_layer > middle_layer:\n            # Lower half of a diamond maze...\n            # Set the roof coordinates for a diamond maze (roof is larger than current layer)\n            roof_position1 = positions.add(maze_position,\n                pos(-2, wall_height, -2))\n            roof_position2 = positions.add(maze_position,\n                pos(maze_columns * 2 + 0, wall_height * 2 - 1, maze_rows * 2 + 0))\n            # Set the entrance offsets for a diamond maze (roof is larger than current layer)\n            x_offset = randint(0, maze_columns - 1) * 2\n            z_offset = randint(0, maze_rows - 1) * 2\n            entrance_position = positions.add(maze_position, pos(x_offset, 0, z_offset))\n            # Move the diamond maze up to the next layer (increasing in size)\n            maze_position = positions.add(maze_position, pos(-2, wall_height * 2, -2))\n        else:\n            # Upper half of a diamond maze...\n            # Set the roof coordinates for a diamond maze (roof is smaller than current layer)\n            roof_position1 = positions.add(maze_position,\n                pos(0, wall_height, 0))\n            roof_position2 = positions.add(maze_position,\n                pos(maze_columns * 2 - 2, wall_height * 2 - 1, maze_rows * 2 - 2))\n            # Set the entrance offsets for a diamond maze (roof is smaller than current layer)\n            x_offset = randint(1, maze_columns - 2) * 2\n            z_offset = randint(1, maze_rows - 2) * 2\n            entrance_position = positions.add(maze_position, pos(x_offset, 0, z_offset))\n            # Move the diamond maze up to the next layer (decreasing in size)\n            maze_position = positions.add(maze_position, pos(2, wall_height * 2, 2))\n        \n    # Draw the floor\n    blocks.fill(wall_blocks, roof_position1, roof_position2, FillOperation.REPLACE)\n    blocks_used += ((roof_position2.get_value(Axis.X) - roof_position1.get_value(Axis.X) + 1) * \n        (roof_position2.get_value(Axis.Y) - roof_position1.get_value(Axis.Y) + 1) * \n        (roof_position2.get_value(Axis.Z) - roof_position1.get_value(Axis.Z) + 1))\n    # Draw the entrance\n    for index in range(3):\n        blocks.fill(SEA_LANTERN, entrance_position,\n            positions.add(entrance_position, pos(0, wall_height * 2 - 1, 0)),\n            FillOperation.REPLACE)\n        loops.pause(100)\n        blocks.fill(AIR, entrance_position,\n            positions.add(entrance_position, pos(0, wall_height * 2 - 1, 0)),\n            FillOperation.REPLACE)\n        loops.pause(100)\n    blocks_used -= wall_height\n    \n    \ndef drawMazeDoors():\n    # Define global variables\n    global player_position, exit_position, entrance_position, blocks_used\n    # Set the exit_position and entrance_position variables\n    if maze_type == \"maze\":\n        exit_position = positions.add(player_position, pos(0, 0, maze_rows * 2 + 2))\n        entrance_position = positions.add(player_position, pos(0, 0, 2))\n    else:\n        exit_position = positions.add(player_position, pos(0, 0, 2))\n    # Draw the exit/entrance\n    for count in range(3):\n        blocks.fill(SEA_LANTERN,\n            exit_position,\n            positions.add(exit_position, pos(0, wall_height - 1, 0)), \n            FillOperation.REPLACE)\n        if maze_type == \"maze\":\n            blocks.fill(SEA_LANTERN, \n                entrance_position, \n                positions.add(entrance_position, pos(0, wall_height - 1, 0)), \n                FillOperation.REPLACE)\n        loops.pause(100)\n        blocks.fill(AIR,\n            exit_position,\n            positions.add(exit_position, pos(0, wall_height - 1, 0)),\n            FillOperation.REPLACE)\n        if maze_type == \"maze\":\n                blocks.fill(AIR,\n                entrance_position,\n                positions.add(entrance_position, pos(0, wall_height - 1, 0)),\n                FillOperation.REPLACE)\n        loops.pause(100)\n    # Update the blocks_used variable to account for the blocks that have been removed\n    blocks_used = blocks_used - wall_height\n    if maze_type == \"maze\":\n        blocks_used = blocks_used - wall_height\n\n\ndef showMazeInfo():\n    # Define global variables\n    global maze_type, time_start, add_torches, blocks_used, torches_used\n    # Initialise local variables\n    time_seconds = Math.round((gameplay.time_query(GAME_TIME) - time_start) / 20)\n    # Display maze information\n    if maze_type == \"maze\":\n        player.say(\"Finished creating maze\")\n    else:\n        player.say(\"Finished creating \" + maze_type + \" maze\")\n    if time_seconds == 1:\n        player.say(\"...Time taken: \" + str(time_seconds) + \" second\")\n    elif time_seconds < 60:\n        player.say(\"...Time taken: \" + str(time_seconds) + \" seconds\")\n    else:\n        time_minutes = Math.round(time_seconds / 60)\n        if time_minutes == 1:\n            player.say(\"...Time taken: \" + str(time_minutes) + \" minute\")\n        else:\n            player.say(\"...Time taken: \" + str(time_minutes) + \" minutes\")\n    player.say(\"...Blocks used: \" + str(blocks_used))\n    if add_torches:\n        player.say(\"...Torches used: \" + str(torches_used))\n\n\ndef solveMaze():\n    # Define global variables\n    global robot_position, robot_orientation, maze_solve_path, entrance_position, exit_position    \n    global searched_steps, solution_steps\n    # Initialise local variables\n    robot_position = entrance_position\n    robot_orientation = \"N\"    \n    maze_solve_loop = True\n    maze_solve_path = []\n    searched_steps = 0\n    solution_steps = 0\n    time_start = gameplay.time_query(GAME_TIME)\n    # Display status message\n    if maze_type == \"maze\":\n        player.say(\"Solving maze...\")\n    else:\n        player.say(\"Solving \" + maze_type + \" maze...\")\n    # Solve the maze, baby...\n    while maze_solve_loop:\n        # Rule 1: If there's air underneath the (invisible) robot, move it down to the next layer\n        if blocks.test_for_block(AIR, positions.add(robot_position, pos(0, -1, 0))):\n            robot_position = positions.add(robot_position, pos(0, -1, 0))\n            maze_solve_path = []\n        # Rule 2: If the (invisible) robot can turn left, then it must turn left\n        elif robotTestForAir(\"Left\"):\n            robotTurn(\"Left\")\n            addToSolvePath(\"L\")\n            moveRobotForward()\n        # Rule 3: If the (invisible) robot can go straight/forward, then it must go straight/forward\n        elif robotTestForAir(\"Forward\"):\n            if robotTestForAir(\"Right\"):\n                addToSolvePath(\"S\")\n            moveRobotForward()\n        # Rule 4: If the (invisible) robot can turn right, then it must turn right\n        elif robotTestForAir(\"Right\"):\n            robotTurn(\"Right\")\n            addToSolvePath(\"R\")\n            moveRobotForward()\n        # Rule 5: If the (invisible) robot is in a dead end, then it must turn back\n        else:\n            blocks.place(path_block, robot_position)\n            loops.pause(200)\n            robotTurn(\"Back\")\n            addToSolvePath(\"B\")\n            moveRobotForward()\n        # Rule 6: If the (invisible) robot is at the exit, then stop solving the maze\n        if robot_position.get_value(Axis.X) == exit_position.get_value(Axis.X):\n            if robot_position.get_value(Axis.Y) == exit_position.get_value(Axis.Y):\n                if robot_position.get_value(Axis.Z) == exit_position.get_value(Axis.Z):\n                    maze_solve_loop = False\n                    moveRobotForward()\n    # Display status messages\n    if maze_type == \"maze\":\n        player.say(\"Finished solving maze\")\n    else:\n        player.say(\"Finished solving \" + maze_type + \" maze\")\n    time_seconds = Math.round((gameplay.time_query(GAME_TIME) - time_start) / 20)\n    if time_seconds < 60:\n        player.say(\"...Time taken: \" + str(time_seconds) + \" seconds\")\n    else:\n        time_minutes = Math.round(time_seconds / 60)\n        if time_minutes == 1:\n            player.say(\"...Time taken: \" + str(time_minutes) + \" minute\")\n        else:\n            player.say(\"...Time taken: \" + str(time_minutes) + \" minutes\")\n    player.say(\"...Path searched: \" + str(searched_steps) + \" steps\")\n    player.say(\"...Path found: \" + str(solution_steps) + \" steps\")\n    \n    \ndef robotTestForAir(direction: str):\n    # Define global variables\n    global robot_position, x_offset, z_offset\n    robotGetXZOffsets(direction)\n    if blocks.test_for_block(wall_blocks,\n        positions.add(robot_position, pos(x_offset, 0, z_offset))):\n            return False\n    else:\n        return True\n\n\ndef robotGetXZOffsets(direction: str):\n    # Define global variables\n    global x_offset, z_offset, robot_orientation\n    # Reset x_offset and z_offset variables\n    x_offset = 0\n    z_offset = 0\n    if robot_orientation == \"N\":\n        if direction == \"Left\":\n            x_offset = 1\n        elif direction == \"Right\":\n            x_offset = -1\n        else:\n            z_offset = 1\n    elif robot_orientation == \"S\":\n        if direction == \"Left\":\n            x_offset = -1\n        elif direction == \"Right\":\n            x_offset = 1\n        else:\n            z_offset = -1\n    elif robot_orientation == \"E\":\n        if direction == \"Left\":\n            z_offset = 1\n        elif direction == \"Right\":\n            z_offset = -1\n        else:\n            x_offset = -1\n    elif robot_orientation == \"W\":\n        if direction == \"Left\":\n            z_offset = -1\n        elif direction == \"Right\":\n            z_offset = 1\n        else:\n            x_offset = 1\n    else:\n        player.say(\"Unknown robot orientation\")\n\n\ndef robotTurn(direction: str):\n    # Define global variables\n    global robot_orientation\n    if robot_orientation == \"N\":\n        if direction == \"Left\":\n            robot_orientation = \"W\"\n        elif direction == \"Right\":\n            robot_orientation = \"E\"\n        else:\n            robot_orientation = \"S\"\n    elif robot_orientation == \"S\":\n        if direction == \"Left\":\n            robot_orientation = \"E\"\n        elif direction == \"Right\":\n            robot_orientation = \"W\"\n        else:\n            robot_orientation = \"N\"\n    elif robot_orientation == \"E\":\n        if direction == \"Left\":\n            robot_orientation = \"N\"\n        elif direction == \"Right\":\n            robot_orientation = \"S\"\n        else:\n            robot_orientation = \"W\"\n    elif robot_orientation == \"W\":\n        if direction == \"Left\":\n            robot_orientation = \"S\"\n        elif direction == \"Right\":\n            robot_orientation = \"N\"\n        else:\n            robot_orientation = \"E\"\n    else:\n        player.say(\"Unknown robot orientation\")\n\n\ndef addToSolvePath(text: str):\n    # Define global variables\n    global maze_solve_path\n    # Add the last step to the solution path\n    maze_solve_path.append(text)\n    # Check if the solution path can be shortened\n    if len(maze_solve_path) >= 3:\n        last_three_steps = \"\"\n        index = len(maze_solve_path) - 3\n        for counter in range(3):\n            last_three_steps = last_three_steps + maze_solve_path[index]\n            index += 1\n        if last_three_steps == \"LBR\":\n            replaceLastThreeSteps(\"B\")\n        elif last_three_steps == \"LBS\":\n            replaceLastThreeSteps(\"R\")\n        elif last_three_steps == \"RBL\":\n            replaceLastThreeSteps(\"B\")\n        elif last_three_steps == \"SBL\":\n            replaceLastThreeSteps(\"R\")\n        elif last_three_steps == \"SBS\":\n            replaceLastThreeSteps(\"B\")\n        elif last_three_steps == \"LBL\":\n            replaceLastThreeSteps(\"S\")\n\n\ndef replaceLastThreeSteps(text: str):\n    # Define global variables\n    global maze_solve_path\n    # Shorten the solution path by replacing the last three steps\n    for index in range(3):\n        maze_solve_path.pop()\n    maze_solve_path.append(text)\n\n\ndef moveRobotForward():\n    # Define global variables\n    global maze_solve_path, robot_position, searched_steps, solution_steps\n    # Move the (invisible) robot forward 1 step\n    if len(maze_solve_path) > 1 and maze_solve_path[len(maze_solve_path) - 1] == \"B\":\n        # Retracing steps, so remove the path behind the (invisible) robot\n        blocks.place(AIR, robot_position)\n        solution_steps -= 1\n    else:\n        # Not retracing steps, so leave a path behind the (invisible) robot\n        blocks.place(path_block, robot_position)\n        solution_steps += 1\n    robotGetXZOffsets(\"Move Forward\")\n    robot_position = positions.add(robot_position, pos(x_offset, 0, z_offset))\n    searched_steps += 1","pxt.json":"{\n    \"name\": \"Minecraft Mazes Braydan, Alex, Seth\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"builder\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v1.5.64\",\n        \"tag\": \"v1.5.64\",\n        \"commits\": \"https://github.com/microsoft/pxt-minecraft/commits/109ccf274c66c0f0ee2db2ca8bfc69c132ee7d61\",\n        \"target\": \"1.5.64\",\n        \"pxt\": \"6.4.34\"\n    },\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}}],"shares":[{"id":"01135-18504-49345-04940","timestamp":1722994772504}]}